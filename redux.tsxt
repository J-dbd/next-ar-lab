서버에서 자꾸 이런 오류가 떠.  Error: Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.
  {dispatch: function, subscribe: ..., getState: ..., replaceReducer: ..., @@observable: ...}
             ^^^^^^^^
    at stringify (<anonymous>)
digest: "26449615"
ChatGPT
이 오류는 서버 측에서 클라이언트 컴포넌트로 함수를 직접 전달할 수 없음을 나타냅니다. 서버 컴포넌트와 클라이언트 컴포넌트 간의 상호작용에서 발생하는 문제입니다. 특히, 서버 측에서 클라이언트 컴포넌트로 Redux 스토어와 같은 객체를 직접 전달하려 할 때 발생할 수 있습니다.

해결 방법
서버에서 Redux 스토어를 설정하고,
클라이언트 컴포넌트에서 스토어를 초기화하며,
클라이언트로 필요한 초기 상태를 전달합니다.
수정된 RootLayout.tsx
서버에서 초기 상태를 생성하고, 이를 클라이언트 컴포넌트로 전달하는 방법을 사용합니다.

lib/store.ts
먼저, Redux 스토어 설정을 확인합니다.

typescript
Copy code
import { configureStore, EnhancedStore } from '@reduxjs/toolkit';
import designTokenReducer from './features/designToken/designTokenSlice';

export const makeStore = (preloadedState = {}) => {
  return configureStore({
    reducer: {
      designToken: designTokenReducer,
    },
    preloadedState,
  });
};

export type AppStore = ReturnType<typeof makeStore>;
export type RootState = ReturnType<AppStore['getState']>;
export type AppDispatch = AppStore['dispatch'];
lib/initializeStoreWithTokens.ts
서버에서 초기 상태를 설정하는 함수입니다.

typescript
Copy code
import { makeStore } from './store';
import { setDesignToken } from './features/designToken/designTokenSlice';
import { readFileSync } from 'fs';
import path from 'path';

async function getDesignToken() {
  const filepath = path.join(process.cwd(), 'public', 'token.json');
  const fileContents = readFileSync(filepath, 'utf8');
  return JSON.parse(fileContents);
}

export async function initializeStoreWithTokens() {
  const store = makeStore();
  const tokens = await getDesignToken();
  store.dispatch(setDesignToken(tokens));

  const currentState = store.getState();
  console.log('Current state after dispatch:', currentState.designToken.tokens);

  return store;
}
app/layout.tsx
서버에서 초기 상태를 생성하고, 이를 클라이언트 컴포넌트로 전달하는 방법을 사용합니다.

typescript
Copy code
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import StoreProvider from "@/app/StoreProvider";
import StyledComponentsRegistry from "@/lib/styled-component/registry";
import { initializeStoreWithTokens } from "@/lib/initializeStoreWithTokens";
import { RootState } from "@/lib/store";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const store = await initializeStoreWithTokens();
  const tokens = store.getState().designToken.tokens;

  const settingTokenIntoHTML = `
    :root {
      --color-primary: ${tokens.colors.primary};
      --color-secondary: ${tokens.colors.secondary};
      --font-base: ${tokens.sizes.fontBase};
      --padding: ${tokens.sizes.padding};
  }
`;

  return (
    <html lang="en">
      <head>
        <style>{settingTokenIntoHTML}</style>
      </head>
      <body className={inter.className}>
        <StoreProvider initialState={store.getState() as RootState}>
          <StyledComponentsRegistry>{children}</StyledComponentsRegistry>
        </StoreProvider>
      </body>
    </html>
  );
}
app/StoreProvider.tsx
클라이언트 컴포넌트에서 초기 상태를 사용하여 Redux 스토어를 설정합니다.

typescript
Copy code
"use client";

import { useMemo } from "react";
import { Provider } from "react-redux";
import { makeStore, AppStore, RootState } from "../lib/store";

interface StoreProviderProps {
  initialState: RootState;
  children: React.ReactNode;
}

export default function StoreProvider({ initialState, children }: StoreProviderProps) {
  const store = useMemo(() => makeStore(initialState), [initialState]);

  return <Provider store={store}>{children}</Provider>;
}
이 구조에서는 서버에서 Redux 스토어의 초기 상태를 설정하고, 클라이언트 컴포넌트에 그 상태를 전달합니다. 클라이언트 컴포넌트는 이 초기 상태를 사용하여 스토어를 설정합니다. 이로 인해 서버와 클라이언트 간의 상태 동기화가 이루어지고, 함수가 직접 전달되지 않으므로 오류가 발생하지 않습니다.